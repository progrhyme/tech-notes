---
title: "2020-05-10"
linkTitle: "2020-05-10"
date: 2020-05-10T09:05:30+09:00
---

## 5/10
### TerraformのKubernetes Providerを試してみる

Kubernetes Provider自体については[Software > Terraform > Providers#Kubernetes]({{< ref "/a/software/terraform/provider/_index.md" >}}#kubernetes)にメモしている。

環境としては、昨日UbuntuデスクトップにインストールしたMicrok8sを使った。  
default namespaceにkubernetes-bootcamp Deploymentを作っていたので、これをTerraform管理にして弄ってみる。

環境構成:

- Ubuntu 18.04 LTS
- microk8s v1.18.2
- terraformer v0.8.7
- terraform v0.12.24
- terraform-provider-kubernetes v1.11.2

参考記事:

- [Kubernetes上のリソースをTerraformで管理するメリットとデメリット | Goldstine研究所](https://blog.mosuke.tech/entry/2019/03/07/k8s-with-terraform/)
- [TerraformでKubernetesのリソース(ConfigMapやSecretなど)を管理する - Qiita](https://qiita.com/literalice/items/61c536ed57701abeb8c8)
- [Terraformでk8sにSecretsを作って使う • masu-mi's blog(Dirty Cache)](https://blog.masu-mi.me/post/2020/03/17/make-k8s-secrets-with-tf/)

#### providers.tf の用意

microk8s用のクラスタに接続するため、下のコマンドでkubeconfigファイルを作った。

```sh
microk8s kubectl config view > ~/tmp/microk8s/kubeconfig 
```

providers.tf に下を記述する:

```HCL
provider "kubernetes" {
  config_path = "~/tmp/microk8s/kubeconfig"
  # ちゃんとした証明書を用意してないからか、これをつけてないとterraformコマンドがコケる
  insecure    = true
}
```

いつもterraformの設定ファイルを書くのにはIntelliJ IDEAを使っていたのだけど、最近VS Codeの拡張機能もHCL v0.12に対応したので、今回はVS Codeを使ってみた。（実は11月にはもう対応していたらしい）

参考: [Software > Terraform > エディタ]({{< ref "/a/software/terraform/editor.md" >}})

#### terraformerによるimport→失敗

terraformerをLinuxbrewでインストール。

```sh
brew install terraformer
```

（実際にはHomebrew Bundleでbundle installしている。）

`terraform init` によって `.terraform/plugins` に取得されたプロバイダーの実行ファイルを `~/.terraform.d/plugins` にコピーする。

…で、importを試したが、なぜか下のようなメッセージが出て失敗する。

```sh
% env KUBECONFIG=~/tmp/microk8s/kubeconfig terraformer import kubernetes --resources=configmaps,deployments,namespaces,pods,secrets,services
2020/05/10 09:22:18 kubernetes importing... configmaps
2020/05/10 09:22:18 kubernetes: configmaps not supported resource
```

他のリソースを先頭にしても同様。

microk8sだから？ よくわからないけど、ここはそんなにやりたいところじゃないので、諦めて手でHCLを書くことにする。

#### HCLを書いてterraform import

`microk8s kubectl get deployment -o yaml` で出力したYAMLを見ながらHCLを書き起こす:

```HCL
resource "kubernetes_deployment" "bootcamp" {
  metadata {
    name = "kubernetes-bootcamp"
    labels = {
      app = "kubernetes-bootcamp"
    }
  }

  spec {
    replicas = 1

    selector {
      match_labels = {
        app = "kubernetes-bootcamp"
      }
    }

    template {
      metadata {
        labels = {
          app = "kubernetes-bootcamp"
        }
      }

      spec {
        container {
          image = "gcr.io/google-samples/kubernetes-bootcamp:v1"
          name  = "kubernetes-bootcamp"
        }
      }
    }
  }
}
```

下のコマンドでimportする

```sh
% terraform import kubernetes_deployment.bootcamp default/kubernetes-bootcamp
kubernetes_deployment.bootcamp: Importing from ID "default/kubernetes-bootcamp"...
kubernetes_deployment.bootcamp: Import prepared!
  Prepared kubernetes_deployment for import
kubernetes_deployment.bootcamp: Refreshing state... [id=default/kubernetes-bootcamp]

Import successful!

The resources that were imported are shown above. These resources are now in
your Terraform state and will henceforth be managed by Terraform.
```

#### HCLを編集してリソースを更新してみる

まずは、さっきの `kubernetes_deployment.bootcamp` の `spec.template.spec.container` に下のようなresources設定を足してみる

```HCL
          resources {
            limits {
              memory = "64Mi"
            }
          }
```

`terraform apply` したログは下の通り:

```
% terraform apply
kubernetes_deployment.bootcamp: Refreshing state... [id=default/kubernetes-bootcamp]

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
  ~ update in-place

Terraform will perform the following actions:

  # kubernetes_deployment.bootcamp will be updated in-place
  ~ resource "kubernetes_deployment" "bootcamp" {
        id = "default/kubernetes-bootcamp"
        :
      ~ spec {
            :
          ~ template {
                :
              ~ spec {
                    :
                  ~ container {
                        :
                      ~ resources {
                          + limits {
                              + memory = "64Mi"
                            }
                        }
                    }
                }
            }
        }

        timeouts {}
    }

Plan: 0 to add, 1 to change, 0 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

kubernetes_deployment.bootcamp: Modifying... [id=default/kubernetes-bootcamp]
kubernetes_deployment.bootcamp: Modifications complete after 1s [id=default/kubernetes-bootcamp]

Apply complete! Resources: 0 added, 1 changed, 0 destroyed.
```

PodsでDeploymentsの様子をwatchしていたが、下のような動きだった。

1. 新しいPodが立ち上がる
1. 古いPodがTerminateされる

ふつうにDeploymentを更新するときと同じで、RollingUpgradeなんだろうと思う。

#### リソースの名前を変えて、再作成してみる

```diff
  resource "kubernetes_deployment" "bootcamp" {
    metadata {
-     name = "kubernetes-bootcamp"
+     name = "kubernetes-bootcamp2"
      labels = {
        app     = "kubernetes-bootcamp"
```

`terraform apply` のログは下の通り（長いので折りたたみにした）:

<details>

```
% terraform apply
kubernetes_deployment.bootcamp: Refreshing state... [id=default/kubernetes-bootcamp]

An execution plan has been generated and is shown below.
Resource actions are indicated with the following symbols:
-/+ destroy and then create replacement

Terraform will perform the following actions:

  # kubernetes_deployment.bootcamp must be replaced
-/+ resource "kubernetes_deployment" "bootcamp" {
      ~ id = "default/kubernetes-bootcamp" -> (known after apply)

      ~ metadata {
          - annotations      = {} -> null
          ~ generation       = 2 -> (known after apply)
            labels           = {
                "app" = "kubernetes-bootcamp"
            }
          ~ name             = "kubernetes-bootcamp" -> "kubernetes-bootcamp2" # forces replacement
            namespace        = "default"
          ~ resource_version = "44171" -> (known after apply)
          ~ self_link        = "/apis/apps/v1/namespaces/default/deployments/kubernetes-bootcamp" -> (known after
apply)
          ~ uid              = "91420400-2545-4c7a-bc23-2fd6769d41a7" -> (known after apply)
        }

      ~ spec {
            :
          ~ strategy {
              ~ type = "RollingUpdate" -> (known after apply)

              ~ rolling_update {
                  ~ max_surge       = "25%" -> (known after apply)
                  ~ max_unavailable = "25%" -> (known after apply)
                }
            }

          ~ template {
              ~ metadata {
                  - annotations      = {} -> null
                  ~ generation       = 0 -> (known after apply)
                    labels           = {
                        "app" = "kubernetes-bootcamp"
                    }
                  + name             = (known after apply)
                  + resource_version = (known after apply)
                  + self_link        = (known after apply)
                  + uid              = (known after apply)
                }

              ~ spec {
                  - active_deadline_seconds          = 0 -> null
                  - automount_service_account_token  = false -> null
                    dns_policy                       = "ClusterFirst"
                    host_ipc                         = false
                    host_network                     = false
                    host_pid                         = false
                  + hostname                         = (known after apply)
                  + node_name                        = (known after apply)
                  - node_selector                    = {} -> null
                    restart_policy                   = "Always"
                  + service_account_name             = (known after apply)
                    share_process_namespace          = false
                    termination_grace_period_seconds = 30

                  ~ container {
                      - args                     = [] -> null
                      - command                  = [] -> null
                        image                    = "gcr.io/google-samples/kubernetes-bootcamp:v1"
                      ~ image_pull_policy        = "IfNotPresent" -> (known after apply)
                        name                     = "kubernetes-bootcamp"
                        stdin                    = false
                        stdin_once               = false
                        termination_message_path = "/dev/termination-log"
                        tty                      = false

                      ~ resources {
                          ~ limits {
                              + cpu    = (known after apply)
                                memory = "64Mi"
                            }

                          + requests {
                              + cpu    = (known after apply)
                              + memory = (known after apply)
                            }
                        }

                      + volume_mount {
                          :
                        }
                    }

                  + image_pull_secrets {
                      + name = (known after apply)
                    }

                  + volume {
                      + name = (known after apply)

                      + aws_elastic_block_store {
                          + fs_type   = (known after apply)
                          + partition = (known after apply)
                          + read_only = (known after apply)
                          + volume_id = (known after apply)
                        }
                      :
                    }
                }
            }
        }

      - timeouts {}
    }

Plan: 1 to add, 0 to change, 1 to destroy.

Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes

kubernetes_deployment.bootcamp: Destroying... [id=default/kubernetes-bootcamp]
kubernetes_deployment.bootcamp: Destruction complete after 0s
kubernetes_deployment.bootcamp: Creating...
kubernetes_deployment.bootcamp: Creation complete after 8s [id=default/kubernetes-bootcamp2]

Apply complete! Resources: 1 added, 0 changed, 1 destroyed.
```

</details>
<p></p>

この場合、Kubernetes的に別々のリソースとして認識されるからだろうけど、リソースの再作成が行われる。  
再作成だからか、変えてない差分もたくさん出てくる。ログではいくらか間引いたが、それでも長くなった。

大事なのは実行ログで、先にDestroyが走ってから、Createされている。

この挙動については、HCLのresource設定で `lifecycle` ブロックを設定することで変えることができる。

```diff
  resource "kubernetes_deployment" "bootcamp" {
    :
+   lifecycle {
+     create_before_destroy = true
+   }
  }
```

これをつけて `metadata.name` を変えて `terraform apply` を再実行すると、期待した動きになった。
最後の実行ログのところだけ下に貼る:

```
% terraform apply
:
  Enter a value: yes

kubernetes_deployment.bootcamp: Creating...
kubernetes_deployment.bootcamp: Creation complete after 8s [id=default/kubernetes-bootcamp3]
kubernetes_deployment.bootcamp: Destroying... [id=default/kubernetes-bootcamp2]
kubernetes_deployment.bootcamp: Destruction complete after 0s

Apply complete! Resources: 1 added, 0 changed, 1 destroyed.
```
