<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>progrhyme's Tech Notes – Memorandum</title><link>https://progrhy.me/tech-notes/a/memo/</link><description>Recent content in Memorandum on progrhyme's Tech Notes</description><generator>Hugo -- gohugo.io</generator><language>ja</language><lastBuildDate>Sat, 25 Apr 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://progrhy.me/tech-notes/a/memo/index.xml" rel="self" type="application/rss+xml"/><item><title>A: 2020-05-24</title><link>https://progrhy.me/tech-notes/a/memo/20200524/</link><pubDate>Sun, 24 May 2020 05:11:54 +0900</pubDate><guid>https://progrhy.me/tech-notes/a/memo/20200524/</guid><description>
&lt;h2 id="524">5/24&lt;/h2>
&lt;h3 id="macosでターミナルの操作動画をタイプしたキーと共に録画する">macOSでターミナルの操作動画をタイプしたキーと共に録画する&lt;/h3>
&lt;p>ブログ用にキャプチャ動画を撮りたいと思った。&lt;/p>
&lt;p>やり方は前に調べて&lt;a href="https://progrhy.me/tech-notes/a/os/mac/#%E7%94%BB%E9%9D%A2%E3%82%92%E5%8B%95%E7%94%BB%E3%81%A7%E6%92%AE%E5%BD%B1%E3%81%97%E3%81%A6gif%E3%82%A2%E3%83%8B%E3%83%A1%E3%81%AB%E5%A4%89%E6%8F%9B">OS &amp;gt; macOS#画面を動画で撮影してGIFアニメに変換&lt;/a>に書いておいた。&lt;/p>
&lt;h4 id="keycastrのインストールとセットアップ">KeyCastrのインストールとセットアップ&lt;/h4>
&lt;p>まず、キー入力を表示するためにKeyCastrを入れる。これは一択である。&lt;/p>
&lt;p>dmgボリュームをマウントし、アプリケーションをいつものフォルダにインストール。&lt;/p>
&lt;p>開発者が未確認のため実行できないようなので、FinderからCtrlキーを押しながらアプリをクリックして「開く」を選ぶ。&lt;/p>
&lt;ul>
&lt;li>参考: &lt;a href="https://support.apple.com/ja-jp/guide/mac-help/mh40616/mac">開発元が未確認のMacアプリケーションを開く - Apple サポート&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>また、たぶんキーボード入力とかディスプレイとか（想像）にアクセスするため、アプリにアクセシビリティを与えてあげないといけない。　　
macOSの「システム環境設定」を開き、「セキュリティとプライバシー &amp;gt; アクセシビリティ &amp;gt; プライバシー」設定画面で、「下のアプリケーションにコンピュータの制御を許可。」のリストにKeyCastrを加える。&lt;br>
設定したら、KeyCastrを再起動する。&lt;/p>
&lt;p>これでタイプしたキーがKeyCastrのウィンドウに表示されるようになった。&lt;br>
ウィンドウが消える前にクリックアンドドラッグすることで、画面上の任意の位置に動かすことができる。&lt;br>
録画のため、ターミナル画面の右下隅あたりに移動しておく。&lt;br>
5文字ぐらいタイプしてみて、右側にはみ出さない程度の位置がベスト。&lt;/p>
&lt;h5 id="追記-macos-catalinaでの設定箇所の違い">追記: macOS Catalinaでの設定箇所の違い&lt;/h5>
&lt;p>Catalinaの場合、アクセシビリティの設定箇所が異なる。&lt;/p>
&lt;p>「システム環境設定」を開き、「セキュリティとプライバシー &amp;gt; 入力監視 &amp;gt; プライバシー」設定画面で、「ほかのアプリケーションの使用中でも、下のアプリケーションにキーボードからの入力の監視を許可。」のリストにKeyCastrを加える。&lt;/p>
&lt;h4 id="ターミナル画面の録画">ターミナル画面の録画&lt;/h4>
&lt;p>いま私はmacOS Mojaveを使っているので、「⌘⇧5」キーを押すことでスクリーンキャプチャを録ることができる。&lt;br>
やってみて気づいたが、このショートカットキーから静止画も撮れるようだ。&lt;/p>
&lt;p>ショートカットキーを押すと撮影位置を表す破線枠と、その下にメニューバーが現れる。
動画を録るには、破線枠で撮影位置を調整した後、メニューバーの真ん中右側の「選択部分を収録」を選んでENTERキーを押す。
すると、録画が開始される。&lt;/p>
&lt;p>録画が終わったらもう一度「⌘⇧5」キーを押して、メニューバーを呼び出し、停止ボタンを押す。すると、動画がデスクトップに保存される。&lt;/p>
&lt;p>なお、ターミナル画面を撮影するときは、以下に気をつけるとよいと思う:&lt;/p>
&lt;ul>
&lt;li>ウィンドウの透過はオフにしておく&lt;/li>
&lt;li>文字サイズを大きめにしておく&lt;/li>
&lt;li>入力するコマンドやキーのアンチョコを用意しておく&lt;/li>
&lt;/ul>
&lt;h4 id="動画をgifアニメ化">動画をGIFアニメ化&lt;/h4>
&lt;p>GIFアニメ化のアプリには、GiftedかPicGIF Liteかの選択肢があったが、Appストアの評価を見てPicGIF Liteに決めた。&lt;br>
使ってみたところ、無料でも機能が充実していて素晴らしいと思った。&lt;/p>
&lt;p>PicGIF Liteを起動し、先ほど録画した動画のmovファイルをドラッグアンドドロップすると、取り込むことができる。&lt;br>
ここでフレームレートを指定できる。
今回は秒間4フレームとした。&lt;/p>
&lt;p>動画を取り込んだ後、余分なフレームを削除したり、順番を入れ替えたりできるようだ。
最初と最後の余計な部分を削った。&lt;/p>
&lt;p>初期状態だとキャンバスが360x240と小さく、画像がぼやけてしまうので、大きめにしておくといい。&lt;br>
今回はプリセットに合わせることを考えておらず、余白が少し大きくなってしまったので、カスタムのキャンバスサイズを定義した。&lt;/p>
&lt;p>以上。&lt;/p>
&lt;h3 id="gitpodというクラウドideがよさそう">GitpodというクラウドIDEがよさそう&lt;/h3>
&lt;p>&lt;a href="https://www.gitpod.io/">https://www.gitpod.io/&lt;/a>&lt;/p>
&lt;p>クラウドIDEでもあるEclipse TheiaベースのオンラインIDE.&lt;br>
GitHub, GitLabの既存プロジェクトをインポートしてワンクリックで開発環境を立ち上げられるそうだ。&lt;/p>
&lt;p>Eclipse TheiaとともにTypeFox社がファウンダー / 開発元。&lt;/p>
&lt;p>参考:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://qiita.com/kai_kou/items/40a7a579f1bce31d6a16">クラウドIDE「Gitpod」を試してみたら予想以上に使えそうだった - Qiita&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://qiita.com/mouse_484/items/394a4984f749cc201422">Gitpodが最強過ぎる件について - Qiita&lt;/a>&lt;/li>
&lt;li>2020-04-03 &lt;a href="https://thinkit.co.jp/news/bn/17456">クラウド・デスクトップ環境コードエディタ「Eclipse Theia 1.0」リリース | Think IT（シンクイット）&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="mbaをcatalinaに上げた">MBAをCatalinaに上げた&lt;/h3>
&lt;p>Macに関する記事をQiitaに上げようと思ったが、せめてその前にCatalinaに上げるべきだろうという謎の義務感によりアップグレードを実行。&lt;/p>
&lt;p>KeyCastrが32ビット版で動かなくなったので、どうやら非公式のサイトからインストールしてしまっていたらしいと気づいた。&lt;/p>
&lt;p>&lt;code>brew cask&lt;/code> でインストールできると知ったので、その方式に変えた。&lt;/p>
&lt;ul>
&lt;li>Brewfileの更新: &lt;a href="https://github.com/progrhyme/myenv/commit/a6bc1671c49a786b16918b12e0b33010e94d5b52">https://github.com/progrhyme/myenv/commit/a6bc1671c49a786b16918b12e0b33010e94d5b52&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="macosのウイルス対策ソフト">macOSのウイルス対策ソフト&lt;/h3>
&lt;p>たまに調べる。&lt;br>
やはりノートンが老舗でバランス良く、安心感ある印象。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://thehikaku.net/security/hikaku.html">セキュリティソフトの比較 2020 - the比較&lt;/a> &amp;hellip; これ表になっててわかりやすい&lt;/li>
&lt;li>&lt;a href="http://monomania.sblo.jp/article/60532423.html">比較2020&amp;rsquo;【Mac用】ウイルス対策ソフト31点のおすすめ；軽いセキュリティソフト: 家電批評モノマニア&lt;/a> &amp;hellip; 縦に長い。ざっと流し見した&lt;/li>
&lt;/ul></description></item><item><title>A: 2020-05-23</title><link>https://progrhy.me/tech-notes/a/memo/20200523/</link><pubDate>Sat, 23 May 2020 16:42:12 +0900</pubDate><guid>https://progrhy.me/tech-notes/a/memo/20200523/</guid><description>
&lt;h2 id="523">5/23&lt;/h2>
&lt;h3 id="gcloud-promptにテストとciを足した">gcloud-promptにテストとCIを足した&lt;/h3>
&lt;p>&lt;a href="https://github.com/progrhyme/gcloud-prompt/pull/1">https://github.com/progrhyme/gcloud-prompt/pull/1&lt;/a>&lt;/p>
&lt;p>複数のシェルから同時に触っても表示が壊れたりしないように、排他制御機構を入れたのだけど、逆にエンバグしそうで怖くなったので、テストを足した。&lt;/p>
&lt;p>テストのため、 &lt;code>gcloud&lt;/code> コマンドの挙動をなんちゃって実装したシェルスクリプトを書いたけど、これはスタブなのだろうか、モックなのだろうかというのが気になった。&lt;br>
とりあえずコメントでは「stub」ということにしておいたけど。&lt;/p>
&lt;p>See &lt;a href="https://progrhy.me/tech-notes/a/software/test/#%E3%82%B9%E3%82%BF%E3%83%96%E3%81%A8%E3%83%A2%E3%83%83%E3%82%AF%E3%81%AE%E9%81%95%E3%81%84">Software &amp;gt; テスト#スタブとモックの違い&lt;/a>&lt;/p>
&lt;p>今回実装した機能を鑑みるに、&lt;/p>
&lt;ul>
&lt;li>&lt;code>gcloud info&lt;/code> や &lt;code>gcloud config&lt;/code> が呼ばれたときに決まった結果を返す -&amp;gt; スタブ&lt;/li>
&lt;li>gcloud-prompt.shから &lt;code>gcloud config&lt;/code> コマンドが呼ばれたときに、呼ばれた回数を記録 -&amp;gt; モック&lt;/li>
&lt;/ul>
&lt;p>両方の性質を合わせ持ってることになるのかな？&lt;/p>
&lt;p>詳しい人いたら教えてほしい。&lt;/p>
&lt;h3 id="basher-link-がmacosで動かなかった">&lt;code>basher link&lt;/code> がmacOSで動かなかった&lt;/h3>
&lt;p>&lt;a href="https://qiita.com/progrhyme/items/3a31282dfd0512a402cc#macos%E3%81%A7coreutils%E3%81%8C%E5%BF%85%E8%A6%81">シェルスクリプトのパッケージマネージャー「basher」の機能概要と使い方 - Qiita&lt;/a>に追記した通り。&lt;/p>
&lt;p>既に修正PRも送っている:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/basherpm/basher/pull/80">modify: Don&amp;rsquo;t use &amp;quot;readlink -f&amp;quot; in &amp;quot;resolve_link&amp;quot; by progrhyme · Pull Request #80 · basherpm/basher&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>デバッグに苦しんだ副産物として、 &lt;code>realpath&lt;/code> をエミュレートするBashスクリプトが出来た:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/progrhyme/bash-realpath">https://github.com/progrhyme/bash-realpath&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>デバッグコードがたくさん残っているので、実験的な意味合いが強いが。&lt;/p></description></item><item><title>A: 2020-05-22</title><link>https://progrhy.me/tech-notes/a/memo/20200522/</link><pubDate>Fri, 22 May 2020 21:47:32 +0900</pubDate><guid>https://progrhy.me/tech-notes/a/memo/20200522/</guid><description>
&lt;h2 id="522">5/22&lt;/h2>
&lt;h3 id="ubuntu-1804でzsh-syntax-highlightingを入れた">Ubuntu 18.04でzsh-syntax-highlightingを入れた&lt;/h3>
&lt;p>zshでの &lt;code>help&lt;/code> コマンドを探していたら &lt;a href="https://wiki.archlinux.jp/index.php/Zsh">https://wiki.archlinux.jp/index.php/Zsh&lt;/a> にたどり着き、&lt;a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting&lt;/a>の存在を知った。&lt;/p>
&lt;p>fish shellのようなシンタックスハイライトを提供してくれるプラグインらしい。&lt;br>
早速試してみることにした。&lt;/p>
&lt;p>&lt;a href="https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md">INSTALL.md&lt;/a>によれば、UbuntuだとxenialかOBSのリポジトリからパッケージで入れるとよさそうだったが、macOSならHomebrewで入れれるようだったので、Linuxbrewでも行けるかまずはやってみることにした。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ brew install zsh-syntax-highlighting
:
&lt;span style="color:#ce5c00;font-weight:bold">==&lt;/span>&amp;gt; Installing dependencies &lt;span style="color:#204a87;font-weight:bold">for&lt;/span> zsh-syntax-highlighting: patchelf, ncurses,
zlib, pcre, gettext, libbsd, expat,gdbm, openssl@1.1, berkeley-db, perl,
texinfo and zsh
:
&lt;/code>&lt;/pre>&lt;/div>&lt;p>けっこう依存が色々あったが、無事にインストールできた。&lt;/p>
&lt;p>試しに &lt;code>source /home/linuxbrew/.linuxbrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&lt;/code> を実行してみると、ちゃんとコマンドなどにハイライトが効くようになった。&lt;/p>
&lt;p>dotfilesの対応は &lt;a href="https://github.com/progrhyme/myenv/commit/63ce3a305e6cfa6b5b247e9eba1f8ef58edb94b5">https://github.com/progrhyme/myenv/commit/63ce3a305e6cfa6b5b247e9eba1f8ef58edb94b5&lt;/a> こんな感じで。&lt;/p>
&lt;p>これで私のZsh環境がまた一歩fish shellに近づいた。&lt;/p>
&lt;p>（追記）macOSにも入れた: &lt;a href="https://github.com/progrhyme/myenv/commit/71cf5a49b5ebc5fbd3dc190e5d3f46fa25d23d3b">https://github.com/progrhyme/myenv/commit/71cf5a49b5ebc5fbd3dc190e5d3f46fa25d23d3b&lt;/a>&lt;/p></description></item><item><title>A: 2020-05-19</title><link>https://progrhy.me/tech-notes/a/memo/20200519/</link><pubDate>Tue, 19 May 2020 20:59:11 +0900</pubDate><guid>https://progrhy.me/tech-notes/a/memo/20200519/</guid><description>
&lt;h2 id="519">5/19&lt;/h2>
&lt;h3 id="basherを使ってみた">basherを使ってみた&lt;/h3>
&lt;p>&lt;a href="../20200518/#clenv%E3%81%AFbasher%E3%81%A7%E5%AE%8C%E5%85%A8%E3%81%AB%E7%BD%AE%E3%81%8D%E6%8F%9B%E3%81%88%E3%82%89%E3%82%8C%E3%81%9D%E3%81%86">昨日見つけたbasherがclenvを置き換えられそうだった&lt;/a>ので、試してみた。&lt;/p>
&lt;p>作業環境はUbuntu 18.04.&lt;/p>
&lt;h4 id="install">Install&lt;/h4>
&lt;p>READMEの通りにやってみる。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ git clone https://github.com/basherpm/basher.git ~/.basher
$ &lt;span style="color:#204a87">export&lt;/span> &lt;span style="color:#000">PATH&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#000">$HOME&lt;/span>&lt;span style="color:#4e9a06">/.basher/bin:&lt;/span>&lt;span style="color:#000">$PATH&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
$ &lt;span style="color:#204a87">eval&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">$(&lt;/span>basher init -&lt;span style="color:#204a87;font-weight:bold">)&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
basher init usage has changed, please specify the name of your shell as an argument:
&lt;span style="color:#204a87">eval&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">$(&lt;/span>basher init - bash&lt;span style="color:#204a87;font-weight:bold">)&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span> &lt;span style="color:#8f5902;font-style:italic"># or zsh, fish, sh etc&lt;/span>
For more information, check this PR: https://github.com/basherpm/basher/pull/77
&lt;/code>&lt;/pre>&lt;/div>&lt;p>初期化コマンドが変わったらしいので、やり直す。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ &lt;span style="color:#204a87">eval&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">$(&lt;/span>basher init - zsh&lt;span style="color:#204a87;font-weight:bold">)&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
$ basher
Usage: basher &amp;lt;command&amp;gt; &lt;span style="color:#ce5c00;font-weight:bold">[&lt;/span>&amp;lt;args&amp;gt;&lt;span style="color:#ce5c00;font-weight:bold">]&lt;/span>
Some useful basher commands are:
&lt;span style="color:#204a87">help&lt;/span> Display &lt;span style="color:#204a87">help&lt;/span> &lt;span style="color:#204a87;font-weight:bold">for&lt;/span> a &lt;span style="color:#204a87">command&lt;/span>
commands List all available basher commands
init Configure the shell environment &lt;span style="color:#204a87;font-weight:bold">for&lt;/span> basher
See &lt;span style="color:#4e9a06">&amp;#39;basher help &amp;lt;command&amp;gt;&amp;#39;&lt;/span> &lt;span style="color:#204a87;font-weight:bold">for&lt;/span> information on a specific command.
$ basher commands
commands
completions
&lt;span style="color:#204a87">help&lt;/span>
init
install
link
list
outdated
package-path
uninstall
upgrade
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="使ってみる">使ってみる&lt;/h4>
&lt;p>まずはシェルスクリプトモジュールをinstallし、includeでシェルに読み込むというのを試す。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">&lt;span style="color:#8f5902;font-style:italic"># 自作のgcloud-promptをインストール&lt;/span>
$ basher install progrhyme/gcloud-prompt
Cloning into &lt;span style="color:#4e9a06">&amp;#39;/home/progrhyme/.basher/cellar/packages/progrhyme/gcloud-prompt&amp;#39;&lt;/span>...
: &lt;span style="color:#8f5902;font-style:italic"># 略&lt;/span>
$ basher list
progrhyme/gcloud-prompt
$ include progrhyme/gcloud-prompt gcloud-prompt.sh
$ gcloud_prompt
default&lt;span style="color:#000;font-weight:bold">|&lt;/span>my-project1,asia-northeast1
&lt;span style="color:#8f5902;font-style:italic"># kube-ps1をインストール&lt;/span>
$ basher install jonmosco/kube-ps1
Cloning into &lt;span style="color:#4e9a06">&amp;#39;/home/progrhyme/.basher/cellar/packages/jonmosco/kube-ps1&amp;#39;&lt;/span>...
: &lt;span style="color:#8f5902;font-style:italic"># 略&lt;/span>
$ include jonmosco/kube-ps1 kube-ps1.sh
$ kube_ps1
&lt;span style="color:#ce5c00;font-weight:bold">(&lt;/span>%&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>%F&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>4&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>%&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>⎈ %&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>%f%&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>&lt;span style="color:#000;font-weight:bold">|&lt;/span>%&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>%F&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>1&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>%&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>reagent_experiment%&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>%f%&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>:%&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>%F&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>6&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>%&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>default%&lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>%f%&lt;span style="color:#ce5c00;font-weight:bold">})&lt;/span>
$ kubeoff
$ kube_ps1
$
&lt;/code>&lt;/pre>&lt;/div>&lt;p>次は実行ファイルを含むリポジトリをinstallしてみる。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ basher install progrhyme/git-wraps
$ ll ~/.basher/cellar/bin/git-*
lrwxrwxrwx &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> progrhyme progrhyme &lt;span style="color:#0000cf;font-weight:bold">77&lt;/span> 5月 &lt;span style="color:#0000cf;font-weight:bold">19&lt;/span> 20:55 /home/progrhyme/.basher/cellar/bin/git-branch-clean -&amp;gt; /home/progrhyme/.basher/cellar/package
s/progrhyme/git-wraps/bin/git-branch-clean
lrwxrwxrwx &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> progrhyme progrhyme &lt;span style="color:#0000cf;font-weight:bold">70&lt;/span> 5月 &lt;span style="color:#0000cf;font-weight:bold">19&lt;/span> 20:55 /home/progrhyme/.basher/cellar/bin/git-pulls -&amp;gt; /home/progrhyme/.basher/cellar/packages/progr
hyme/git-wraps/bin/git-pulls
lrwxrwxrwx &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> progrhyme progrhyme &lt;span style="color:#0000cf;font-weight:bold">74&lt;/span> 5月 &lt;span style="color:#0000cf;font-weight:bold">19&lt;/span> 20:55 /home/progrhyme/.basher/cellar/bin/git-pulls-all -&amp;gt; /home/progrhyme/.basher/cellar/packages/p
rogrhyme/git-wraps/bin/git-pulls-all
lrwxrwxrwx &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> progrhyme progrhyme &lt;span style="color:#0000cf;font-weight:bold">72&lt;/span> 5月 &lt;span style="color:#0000cf;font-weight:bold">19&lt;/span> 20:55 /home/progrhyme/.basher/cellar/bin/git-skelton -&amp;gt; /home/progrhyme/.basher/cellar/packages/pro
grhyme/git-wraps/bin/git-skelton
lrwxrwxrwx &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> progrhyme progrhyme &lt;span style="color:#0000cf;font-weight:bold">83&lt;/span> 5月 &lt;span style="color:#0000cf;font-weight:bold">19&lt;/span> 20:55 /home/progrhyme/.basher/cellar/bin/git-submodule-all-pull -&amp;gt; /home/progrhyme/.basher/cellar/p
ackages/progrhyme/git-wraps/bin/git-submodule-all-pull
lrwxrwxrwx &lt;span style="color:#0000cf;font-weight:bold">1&lt;/span> progrhyme progrhyme &lt;span style="color:#0000cf;font-weight:bold">81&lt;/span> 5月 &lt;span style="color:#0000cf;font-weight:bold">19&lt;/span> 20:55 /home/progrhyme/.basher/cellar/bin/git-submodule-delete -&amp;gt; /home/progrhyme/.basher/cellar/pac
kages/progrhyme/git-wraps/bin/git-submodule-delete
$ basher list
jonmosco/kube-ps1
progrhyme/gcloud-prompt
progrhyme/git-wraps
&lt;/code>&lt;/pre>&lt;/div>&lt;p>ふつうに使えそう。&lt;br>
bin/* 以下のものはsymlinkなので、例えば実行ファイルが「同じリポジトリに含まれる lib/foo.sh に依存するシェルスクリプト」だとしても問題なく動くはず。&lt;/p>
&lt;p>一応このケースも試しておく:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ basher install progrhyme/shove
$ ~/.basher/cellar/bin/shove
Run tests by /bin/zsh
-------------------------
Test Summary Report
-------------------
All tests successful.
&lt;span style="color:#000">Files&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>0, &lt;span style="color:#000">Tests&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>0, &lt;span style="color:#000">Successes&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>0, &lt;span style="color:#000">Failures&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">0&lt;/span>
Result: PASS
&lt;/code>&lt;/pre>&lt;/div>&lt;p>問題なし。&lt;/p>
&lt;h4 id="パッケージリストの管理ができるかどうか">パッケージリストの管理ができるかどうか&lt;/h4>
&lt;p>Brewfileとかbundlerのようなことをやりたい。&lt;br>
clenvだと、 &lt;code>Clamfile&lt;/code> っていうので管理できるようにしていた。&lt;/p>
&lt;p>どうやらそれそのものの機能はないようだけど、ローカルのディレクトリをパッケージとしてインストールする &lt;code>link&lt;/code> サブコマンドと、 &lt;code>package.sh&lt;/code> に記した依存するパッケージを追加でインストールする、という機能によって、できなくはない、ということがわかった。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ mkdir test-basher-package
$ cat &lt;span style="color:#4e9a06">&amp;lt;&amp;lt;EOS &amp;gt; test-basher-package/package.sh
&lt;/span>&lt;span style="color:#4e9a06">DEPS=progrhyme/shove:progrhyme/toolbox
&lt;/span>&lt;span style="color:#4e9a06">EOS&lt;/span>
$ basher link test-basher-package progrhyme/test-basher-package
Package &lt;span style="color:#4e9a06">&amp;#39;progrhyme/shove&amp;#39;&lt;/span> is already present
Cloning into &lt;span style="color:#4e9a06">&amp;#39;/home/progrhyme/.basher/cellar/packages/progrhyme/toolbox&amp;#39;&lt;/span>...
: &lt;span style="color:#8f5902;font-style:italic"># 略&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>shoveはさっきインストールしたのでスキップされている。&lt;/p>
&lt;p>このテスト用のパッケージをuninstallしても、依存パッケージは残ったまま。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ basher uninstall progrhyme/test-basher-package
$ basher list
jonmosco/kube-ps1
progrhyme/gcloud-prompt
progrhyme/git-wraps
progrhyme/shove
progrhyme/toolbox
&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみにこの &lt;code>basher link&lt;/code> で実際に起こることしては &lt;code>~/.basher/cellar/packages/&lt;/code> にsymlinkされるだけなので、処理としては軽い。&lt;/p>
&lt;p>なので、例えば適当なディレクトリに &lt;code>package.sh&lt;/code> を置いて、そこに DEPS で自分が使いたいパッケージのリストを記しておき、一時的にそのディレクトリを &lt;code>basher link&lt;/code> でローカルインストールした後、削除する、ということをすれば、DEPSに記したパッケージリストをインストールできる。&lt;/p>
&lt;p>…が、わざわざそんなことをするぐらいなら、パッケージリストを配列にでも入れてforループで処理してしまえば十分だと思った。&lt;/p>
&lt;p>（追記）自分では&lt;a href="https://github.com/progrhyme/myenv/compare/de911093ac1493edb80b402df97f2e55a6e38a47...96760448e5f819aeaa5d00af19590c724995e703#diff-c52f04761593f00b4f12c50e8460a1ee">こんな感じ&lt;/a>で実装した。&lt;br>
後で、この &lt;code>basher_bundle_install&lt;/code> を実行するだけのコマンド &lt;code>basher-bundle-install&lt;/code> を作った。&lt;/p>
&lt;h3 id="ubuntu-zshでbasherに乗り換えてみた">Ubuntu Zshでbasherに乗り換えてみた&lt;/h3>
&lt;p>挙動を確認できたので、clenv -&amp;gt; basherへの移行を進めようかと思って、やってみた。&lt;/p>
&lt;p>下のような形で対応できた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/progrhyme/myenv/compare/de911093ac1493edb80b402df97f2e55a6e38a47...96760448e5f819aeaa5d00af19590c724995e703">Comparing de911093ac&amp;hellip;96760448e · progrhyme/myenv&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>一応他の環境には影響を与えないようにやったけど、他の環境でもすぐに乗り換えてしまおうと思っている。&lt;/p>
&lt;h4 id="追記-その後の対応">追記: その後の対応&lt;/h4>
&lt;ul>
&lt;li>5/22 Ubuntu Bashで乗り換え
&lt;ul>
&lt;li>&lt;a href="https://github.com/progrhyme/myenv/commit/f3430b33ecd261684b518224ff0eb1f42d3ad594">https://github.com/progrhyme/myenv/commit/f3430b33ecd261684b518224ff0eb1f42d3ad594&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>5/23 Mac Book Airで乗り換え
&lt;ul>
&lt;li>&lt;a href="https://github.com/progrhyme/myenv/commit/2e581fcbd0142250708aeaf7152f76569b72ad7a">https://github.com/progrhyme/myenv/commit/2e581fcbd0142250708aeaf7152f76569b72ad7a&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>A: 2020-05-18</title><link>https://progrhy.me/tech-notes/a/memo/20200518/</link><pubDate>Mon, 18 May 2020 22:29:04 +0900</pubDate><guid>https://progrhy.me/tech-notes/a/memo/20200518/</guid><description>
&lt;h2 id="518">5/18&lt;/h2>
&lt;h3 id="clenvは2つのプロジェクトに分割した方がいいかもしれない">clenvは2つのプロジェクトに分割した方がいいかもしれない&lt;/h3>
&lt;p>&lt;a href="https://github.com/progrhyme/clenv">https://github.com/progrhyme/clenv&lt;/a>&lt;/p>
&lt;p>拙作のシェル環境管理ツールだが、やりたいことと実現方法がマッチしてないかも？ OR やりたいことが曖昧かも？ という気がしてきた。&lt;/p>
&lt;p>主なユースケース:&lt;/p>
&lt;ol>
&lt;li>実行ファイルをPATHの通ったところに置きたい&lt;/li>
&lt;li>シェルスクリプトモジュールを管理したい。任意のスクリプトから好きなときに呼び出して使ったり、自分のシェル環境で読み込んで使いたい&lt;/li>
&lt;/ol>
&lt;p>備考:&lt;/p>
&lt;ul>
&lt;li>
&lt;ol>
&lt;li>はシェルスクリプトだけでなく、バイナリ形式で配布されているものも取得できた方が便利。参考: &lt;a href="https://github.com/Songmu/ghg">https://github.com/Songmu/ghg&lt;/a>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>シェルスクリプトの中には単独で完結してなくて、リポジトリに同梱しているシェルスクリプトに依存しているものもあるので、そういうのは上手くやらないといけない。これはclenvで既に達成している（はず）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>現状の（構想の）問題点:&lt;/p>
&lt;ul>
&lt;li>
&lt;ol>
&lt;li>をやるにしろ、2. をやるにしろ、モジュールのバージョン管理はtoo muchである&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>環境を分けて管理する機能も要らない。自分でも &lt;code>default&lt;/code> しか使ってないし&lt;/li>
&lt;/ul>
&lt;p>参考:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://progrhy.me/tech-notes/a/cli/shell/pkg-man/">シェル &amp;gt; パッケージ管理&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="新プロジェクト構想">新プロジェクト構想&lt;/h4>
&lt;p>①実行ファイル取って来る君&lt;/p>
&lt;p>仮称「binpack」とする。&lt;/p>
&lt;ul>
&lt;li>ghgとclamの機能を混ぜる&lt;/li>
&lt;li>clenvみたいに複数環境は要らなくて、最低限、実行ファイルを所定のパスに展開できればいい&lt;/li>
&lt;li>シェルスクリプトで書く必要なし。配布が面倒なのは嫌なので1バイナリにできて書きやすいGoかRustで、GitHubのライブラリがあるといいな&lt;/li>
&lt;/ul>
&lt;p>Issues:&lt;/p>
&lt;ul>
&lt;li>実行ファイル名が衝突したらどうするか？&lt;/li>
&lt;/ul>
&lt;p>②シェルスクリプトのモジュール管理&lt;/p>
&lt;p>仮称「shellter」とする。&lt;/p>
&lt;ul>
&lt;li>clenvみたいに &lt;code>lib/&lt;/code> にsymlink貼る必要なし。 &lt;code>modules/$module&lt;/code> とかに展開したら、所定のルールで読み込めればいい&lt;/li>
&lt;li>cllibみたいに動的にロードするシェル関数もあるといい&lt;/li>
&lt;li>&lt;code>load $module&lt;/code> とやったら、 &lt;code>$module&lt;/code> で所定のパスにあるスクリプトが読めればいいだろう&lt;/li>
&lt;/ul>
&lt;h4 id="既にやられていたかも">既にやられていたかも&lt;/h4>
&lt;p>RustのGitHubライブラリ探してたら、丁度作ろうとしていたものを見つけたかも？&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://crates.io/crates/sheldon">sheldon - crates.io: Rust Package Registry&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>これでいいんじゃないか？&lt;/p>
&lt;p>……うーん、実行ファイルを含むパッケージの場合、各ディレクトリごとにPATHに入れることはできるようだが、まとめて &lt;code>$SHLDON_ROOT/bin/&lt;/code> とかに入れれるかわからん。&lt;br>
どっちかというと、シェルプラグイン管理に重きを置かれている印象。&lt;br>
少し拡張すればできそうだけど。&lt;/p>
&lt;h4 id="追記-completion対応">追記: COMPLETION対応&lt;/h4>
&lt;p>実行ファイルとセットでcompletionファイルをロードするようにしたいこともある。&lt;br>
そういう場合はやっぱりclenvやbasherみたいにセットで管理できた方が便利かな。&lt;/p>
&lt;h3 id="clenvはbasherで完全に置き換えられそう">clenvはbasherで完全に置き換えられそう&lt;/h3>
&lt;p>&lt;a href="https://github.com/basherpm/basher">https://github.com/basherpm/basher&lt;/a>&lt;/p>
&lt;p>ライブラリのロードが &lt;code>include user/repo lib/file.sh&lt;/code> みたいにして行けるので、一昨日作った gcloud-prompt だったら、 &lt;code>include progrhyme/gcloud-prompt gcloud-prompt.sh&lt;/code> で行ける。簡単。&lt;/p>
&lt;p>どうもパッケージの &lt;code>bin/&lt;/code> 以下に置いたものが自動でデフォルトだと &lt;code>$HOME/.basher/celler/bin/&lt;/code> に展開されるっぽい。symlinkかもしれんが。&lt;/p></description></item><item><title>A: 2020-05-17</title><link>https://progrhy.me/tech-notes/a/memo/20200517/</link><pubDate>Sun, 17 May 2020 16:22:33 +0900</pubDate><guid>https://progrhy.me/tech-notes/a/memo/20200517/</guid><description>
&lt;h2 id="517">5/17&lt;/h2>
&lt;h3 id="gcloud-prompt作った">gcloud-prompt作った&lt;/h3>
&lt;p>これ: &lt;a href="https://github.com/progrhyme/gcloud-prompt">https://github.com/progrhyme/gcloud-prompt&lt;/a>&lt;/p>
&lt;p>作り始める前に、一応既存のがないかは調べた。
下が見つかった:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/antoniomo/gcloud-ps1">https://github.com/antoniomo/gcloud-ps1&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/ocadaruma/zsh-gcloud-prompt">https://github.com/ocadaruma/zsh-gcloud-prompt&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>上はactiveなconfigurationを表示しているだけ。&lt;br>
下は逆に、 &lt;code>default&lt;/code> configuration前提で、 &lt;code>account&lt;/code>, &lt;code>project&lt;/code> の情報を表示している。&lt;/p>
&lt;p>自分のニーズとしては、 &lt;code>project&lt;/code> や &lt;code>compute.region&lt;/code> を入れたい。&lt;br>
あまりconfigurationsを活用できてないけど、なるべくconfigurationsで管理していきたい気持ちはあるので、activeなconfigurationも表示したいと思った。&lt;/p>
&lt;p>…で、上のgcloud-ps1のコードを参考にしながら、とりあえずMacの.zshrcにベタに実装していたが、愚直に実装するとgcloudコマンドが遅すぎて使い物にならないことに気がついた。&lt;/p>
&lt;p>コマンド1回で0.3sぐらいかかってたので、configuration, project, compute.regionをそれぞれ取得していたら、ENTERを打つたびに1秒待つことになる。&lt;br>
さすがに無理である。&lt;/p>
&lt;h4 id="activeなconfigurationの取得">activeなconfigurationの取得&lt;/h4>
&lt;p>そこで、activeなconfigurationの取得については、環境変数CLOUDSDK_ACTIVE_CONFIG_NAMEが設定されていればそちらを、そうでなければ &lt;code>$HOME/.config/gcloud/active_config&lt;/code> を直接見ることにした。&lt;/p>
&lt;h4 id="configパラメータの取得">configパラメータの取得&lt;/h4>
&lt;p>…で、configパラメータの取得だが、現在の設定リストは &lt;code>default&lt;/code> configurationであれば &lt;code>$HOME/.config/gcloud/configurations/config_default&lt;/code> に保存されている。&lt;br>
ただし、INIファイル形式で、さすがにシェルスクリプトで自前でパースするのはしんどそう。&lt;/p>
&lt;p>CLIリファレンスを読み込んでいると、 &lt;code>gcloud config list --format=FORMAT&lt;/code> オプションで任意のキーを所望のフォーマットで取得できることがわかった。&lt;/p>
&lt;p>これも毎回実行していると遅いので、コマンドの実行結果をキャッシュファイルに書いて、上のファイルとのタイムスタンプを比較して、更新されていなければキャッシュファイルをcatして返すようにした。&lt;/p>
&lt;h4 id="clenv対応">clenv対応&lt;/h4>
&lt;p>submoduleにしたくなかったので、&lt;a href="https://github.com/progrhyme/clenv/blob/master/bin/clam">clenv/bin/clam&lt;/a>でinstallできるようにした。&lt;br>
なにげに自作のシェルスクリプトライブラリを自分のシェル環境で常にロードして使うのは初めてだったのかも？&lt;/p>
&lt;p>自分で作ったclenvの使い方をすっかり忘れていたので、ソースを解読して使い方を把握した。&lt;/p>
&lt;pre>&lt;code>name=gcloud-prompt
version=0.5.0
libraries=&amp;quot;gcloud-prompt.sh&amp;quot;
&lt;/code>&lt;/pre>&lt;p>上を &lt;code>clam.spec&lt;/code> ってファイルで作っておくとclamでインストールして、 &lt;code>gcloud-prompt.sh&lt;/code> を&lt;a href="https://github.com/progrhyme/clenv/blob/master/bin/cload">clenv/bin/cload&lt;/a>で読み込めるところに配置してくれる。&lt;/p>
&lt;p>シェル環境の方の対応コミットは下:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/progrhyme/myenv/commit/7d9b708187836fcafc03591808e17eda88dded62">https://github.com/progrhyme/myenv/commit/7d9b708187836fcafc03591808e17eda88dded62&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>clenvのライブラリをロードするコードがなかったので、追加した。&lt;/p></description></item><item><title>A: 2020-05-16</title><link>https://progrhy.me/tech-notes/a/memo/20200516/</link><pubDate>Sat, 16 May 2020 01:56:37 +0900</pubDate><guid>https://progrhy.me/tech-notes/a/memo/20200516/</guid><description>
&lt;h2 id="516">5/16&lt;/h2>
&lt;h3 id="zshをfishっぽくいい感じにできた">zshをfishっぽくいい感じにできた&lt;/h3>
&lt;p>&lt;a href="../20200513/#fish%E3%81%A7%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E3%81%84%E3%81%84%E3%81%A8%E6%80%9D%E3%81%A3%E3%81%9F%E6%A9%9F%E8%83%BD%E3%81%AFzsh%E3%81%A7%E3%82%82%E3%81%A7%E3%81%8D%E3%81%9D%E3%81%86">5/13にfishでちょっといいと思った機能はzshでもできそう&lt;/a>だと気がついたので、やってみた。&lt;br>
…で、やってみたらできた。&lt;/p>
&lt;p>作業環境はUbuntu 18.04.&lt;/p>
&lt;p>やったこと:&lt;/p>
&lt;ol>
&lt;li>oh-my-zshをインストール&lt;/li>
&lt;li>テーマを選ぶ&lt;/li>
&lt;li>shrink-pathを設定し、プロンプトをいい感じに調整&lt;/li>
&lt;li>zsh-autosuggestionsをインストールして設定&lt;/li>
&lt;/ol>
&lt;p>1つずつ軽く振り返っておく。&lt;/p>
&lt;h4 id="oh-my-zshをインストール">oh-my-zshをインストール&lt;/h4>
&lt;p>&lt;a href="https://github.com/ohmyzsh/ohmyzsh">https://github.com/ohmyzsh/ohmyzsh&lt;/a>&lt;/p>
&lt;p>README.mdの通りに。一応 tools/install.sh の中身はざっと見た。&lt;br>
zshじゃないとデフォルトではchshされてしまうのと、インストール後に &lt;code>zsh -l&lt;/code> が走ることは確認した上で、そのまま実行:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">sh -c &lt;span style="color:#4e9a06">&amp;#34;&lt;/span>&lt;span style="color:#204a87;font-weight:bold">$(&lt;/span>curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh&lt;span style="color:#204a87;font-weight:bold">)&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>元の ~/.zshrc は退避された上で、oh-my-zshが作った ~/.zshrc が配置されていることに気づいた。&lt;br>
とりあえず自分の ~/.zshrc に戻して、oh-my-zshが作った ~/.zshrc の記述を ~/.zshenv と ~/.zshrc に追記する。&lt;/p>
&lt;p>これだけでも &lt;code>PROMPT&lt;/code> が変わって、見た目が変わったなという印象。&lt;/p>
&lt;p>ただ、自分は &lt;code>RPROMPT&lt;/code> に色々詰め込んでいるので、調整が必要。&lt;/p>
&lt;p>プロンプトについては次とその次のステップで調整する。&lt;/p>
&lt;h4 id="テーマを選ぶ">テーマを選ぶ&lt;/h4>
&lt;p>&lt;a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">https://github.com/ohmyzsh/ohmyzsh/wiki/Themes&lt;/a> から選ぶ。&lt;br>
Externalなテーマもあるらしいけど、今は興味なし。&lt;br>
上から見ていって、&lt;a href="https://github.com/agnoster/agnoster-zsh-theme">agnoster&lt;/a>がよさげだったので、君に決めた。&lt;/p>
&lt;p>これもデフォルトだと左PROMPTが長くて、しかもリポジトリのREADMEの通りにやろうとしても &lt;code>AGNOSTER_*&lt;/code> な変数はセットされていない。&lt;/p>
&lt;p>仕方ないので、&lt;code>~/.oh-my-zsh/themes/agnoster.zsh-theme&lt;/code> で定義されている &lt;code>build_prompt()&lt;/code> 関数を自分の ~/.zshrc の中でオーバーライドすることにした。&lt;/p>
&lt;p>&lt;code>agnoster.zsh-theme&lt;/code> を覗くと次のようになっていたので、それで行けそうだと思った。&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ tail ~/.oh-my-zsh/themes/agnoster.zsh-theme
&lt;span style="color:#8f5902;font-style:italic">## Main prompt&lt;/span>
build_prompt&lt;span style="color:#ce5c00;font-weight:bold">()&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">RETVAL&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#000">$?&lt;/span>
prompt_status
prompt_virtualenv
prompt_aws
prompt_context
prompt_dir
prompt_git
prompt_bzr
prompt_hg
prompt_end
&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>
&lt;span style="color:#000">PROMPT&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#39;%{%f%b%k%}$(build_prompt) &amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="shrink-pathを設定しプロンプトをいい感じに調整">shrink-pathを設定し、プロンプトをいい感じに調整&lt;/h4>
&lt;p>shrink-pathは標準プラグインとしてoh-my-zshに同梱されている。&lt;/p>
&lt;p>&lt;a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/shrink-path">https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/shrink-path&lt;/a>&lt;/p>
&lt;p>このパスにREADME.mdも置かれているので、読むと使い方がわかる。&lt;/p>
&lt;p>利用するには .zshrc 内で &lt;code>plugins+=(shrink-path)&lt;/code> すればいい。&lt;/p>
&lt;p>それから、 &lt;code>PROMPT&lt;/code> や &lt;code>RPROMPT&lt;/code> 内に &lt;code>'$(shrink-path -f)'&lt;/code> と記すと、ホームディレクトリからの絶対パスで、親ディレクトリは先頭1文字に縮めて表示してくれる。&lt;/p>
&lt;p>最終的に、agnoster.zsh-themeの &lt;code>build_prompt()&lt;/code> 関数を次のように書き換えた:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">build_prompt&lt;span style="color:#ce5c00;font-weight:bold">()&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">{&lt;/span>
&lt;span style="color:#000">RETVAL&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#000">$?&lt;/span>
prompt_status
prompt_segment blue &lt;span style="color:#000">$CURRENT_FG&lt;/span> &lt;span style="color:#204a87;font-weight:bold">$(&lt;/span>shrink_path -f&lt;span style="color:#204a87;font-weight:bold">)&lt;/span>
prompt_git
prompt_end
&lt;span style="color:#ce5c00;font-weight:bold">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>これで下のような感じになった。&lt;/p>
&lt;figure>
&lt;img src="ohmyzsh_capture.png"
alt="terminal screenshot with oh-my-zsh"/>
&lt;/figure>
&lt;h4 id="zsh-autosuggestionsをインストールして設定">zsh-autosuggestionsをインストールして設定&lt;/h4>
&lt;p>&lt;a href="https://github.com/zsh-users/zsh-autosuggestions">https://github.com/zsh-users/zsh-autosuggestions&lt;/a>&lt;/p>
&lt;p>INSTALL.md に従って、次のコマンドを実行:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">git clone https://github.com/zsh-users/zsh-autosuggestions &lt;span style="color:#4e9a06">${&lt;/span>&lt;span style="color:#000">ZSH_CUSTOM&lt;/span>&lt;span style="color:#204a87;font-weight:bold">:-&lt;/span>&lt;span style="color:#000;font-weight:bold">~/.oh-my-zsh/custom&lt;/span>&lt;span style="color:#4e9a06">}&lt;/span>/plugins/zsh-autosuggestions
&lt;/code>&lt;/pre>&lt;/div>&lt;p>残念ながら今の環境は256色に対応してないみたいで、次のように設定した:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">&lt;span style="color:#000">ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span>&lt;span style="color:#4e9a06">&amp;#34;fg=green,bold&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>下のような感じでサジェストが出る。&lt;/p>
&lt;figure>
&lt;img src="zsh_autosuggestions.png"
alt="screenshot of zsh-autosuggestions"/>
&lt;/figure>
&lt;p>&lt;code>Ctrl+e&lt;/code> or &lt;code>Ctrl+f&lt;/code> でサジェスト候補を選択できる。&lt;/p>
&lt;p>参考:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://qiita.com/hinatades/items/d38be4830191f251935d">ターミナルでコマンド履歴の入力補完 - Qiita&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>もうこれは完全にfishと言っていいだろう。&lt;/p>
&lt;p>…というか、自分にとってはfishをセットアップするより楽だった気がする。&lt;/p>
&lt;p>今回の変更は次の2コミットに該当する:&lt;/p>
&lt;ul>
&lt;li>dotfilesの変更: &lt;a href="https://github.com/progrhyme/myenv/commit/b4ef98a8b1ef9ae6f0a39532590d79c8161fc161">https://github.com/progrhyme/myenv/commit/b4ef98a8b1ef9ae6f0a39532590d79c8161fc161&lt;/a>&lt;/li>
&lt;li>セットアップスクリプトへの反映: &lt;a href="https://github.com/progrhyme/myenv/commit/96a552660c9b79dcf73a1e87a8fc6664d33864f4">https://github.com/progrhyme/myenv/commit/96a552660c9b79dcf73a1e87a8fc6664d33864f4&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>※oh-my-zshが勝手に &lt;code>PAGER=less&lt;/code> と &lt;code>LESS=-R&lt;/code> を設定していやがったので、.zshrc内でunsetしている。&lt;/p>
&lt;h3 id="macbookでもoh-my-zshをセットアップ">MacBookでもoh-my-zshをセットアップ&lt;/h3>
&lt;p>Ubuntuと同様で、特にハマることはなかった。&lt;/p>
&lt;p>セットアップコードのリファクタリングを行った。&lt;/p>
&lt;ul>
&lt;li>リファクタ: &lt;a href="https://github.com/progrhyme/myenv/commit/dac7a0695ec3d81269d0adc6bfc9c2750753be3a">https://github.com/progrhyme/myenv/commit/dac7a0695ec3d81269d0adc6bfc9c2750753be3a&lt;/a>&lt;/li>
&lt;li>macOS用の対応: &lt;a href="https://github.com/progrhyme/myenv/commit/e35842708298c0803a2f655affc56d3c653f61af">https://github.com/progrhyme/myenv/commit/e35842708298c0803a2f655affc56d3c653f61af&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="macbookにiterm2を入れて設定してみた">MacBookにiTerm2を入れて設定してみた&lt;/h3>
&lt;p>&lt;a href="../20200513/#iterm2%E3%81%AF%E3%82%BF%E3%83%BC%E3%83%9F%E3%83%8A%E3%83%ABapp%E3%81%A8%E6%AF%94%E3%81%B9%E3%81%A6%E4%BD%95%E3%81%8C%E8%89%AF%E3%81%84%E3%81%AE%E3%81%8B">iTerm2良いよーっていうミームを受け取った&lt;/a>ので、試しに使ってみることにした。&lt;/p>
&lt;p>See also &lt;a href="https://progrhy.me/tech-notes/a/software/terminal/iterm2/">Software &amp;gt; ターミナル &amp;gt; iTerm2&lt;/a>&lt;/p>
&lt;h4 id="install">Install&lt;/h4>
&lt;p>&lt;a href="https://iterm2.com/downloads.html">https://iterm2.com/downloads.html&lt;/a> から最新安定版を入手して普通にインストール。&lt;/p>
&lt;h4 id="初期設定">初期設定&lt;/h4>
&lt;p>とりあえず &lt;code>Preferences &amp;gt; Profiles&lt;/code> で「Default」プロファイルを弄る:&lt;/p>
&lt;ul>
&lt;li>Colors &amp;hellip; デフォルトの「Dark Background」をベースに微調整&lt;/li>
&lt;li>Text
&lt;ul>
&lt;li>フォントを「Roboto Mono for Powerline」の16ptに&lt;/li>
&lt;li>よくわからんが「Blinking text」にチェック&lt;/li>
&lt;li>「Use built-in Powerline glyphs」にもチェックしてみた。フォントの見た目がちょっと変わった&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Window
&lt;ul>
&lt;li>透明度を適当に設定&lt;/li>
&lt;li>Settings for New Windows
&lt;ul>
&lt;li>幅と高さをいい感じに調整&lt;/li>
&lt;li>Screen: 「Screen with Cursor」にした&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Terminal &amp;hellip; &lt;code>Scrollback lines&lt;/code> を「3000」にした&lt;/li>
&lt;/ul>
&lt;p>NOTE:&lt;/p>
&lt;ul>
&lt;li>Colors:
&lt;ul>
&lt;li>&lt;code>Cursor Colors &amp;gt; Cursor Boost&lt;/code> が何の設定なのかわからん&lt;/li>
&lt;li>ディレクトリやシェルスクリプトのコメントがCyan.Brightになるのが違和感ある&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>また、 &lt;code>Preferences &amp;gt; Keys &amp;gt; Hotkey&lt;/code> でホットキーも設定しておく。&lt;br>
なんとなく &lt;code>⌥ + ⌘ + ENTER&lt;/code> にした。&lt;/p>
&lt;p>参考:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://qiita.com/koh110/items/b7e9471330308fdb7250">iterm2の設定覚え書き - Qiita&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="shell-integrationの導入">Shell Integrationの導入&lt;/h4>
&lt;p>&lt;a href="https://www.rasukarusan.com/entry/2019/04/13/180443">俺よりiTerm使いこなしてるやつおる？ - ハイパーマッスルエンジニアになりたい&lt;/a>によれば、とりあえずShell Integrationは入れろということらしい。&lt;br>
ので、素直に入れてみる。&lt;/p>
&lt;p>&lt;a href="https://www.iterm2.com/documentation-shell-integration.html">https://www.iterm2.com/documentation-shell-integration.html&lt;/a>&lt;/p>
&lt;p>のガイドに従い、次のコマンドでzsh用のスクリプトを取得:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">curl -L https://iterm2.com/shell_integration/zsh &lt;span style="color:#4e9a06">\
&lt;/span>&lt;span style="color:#4e9a06">&lt;/span>-o ~/.iterm2_shell_integration.zsh
&lt;/code>&lt;/pre>&lt;/div>&lt;p>読み込むと、プロンプトの左端に小さな矢印がついて、実行コマンドの成否がわかる。&lt;br>
機能がagnosterのプロンプトと被っているので、.zshrcを次のように変更して、iTerm2のShell Integrationを有効化したら、agnosterのプロンプトを調整することにした。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/progrhyme/myenv/commit/232924a0cd51ab4902a3e45a6a3ff25e2d0b5bd8">https://github.com/progrhyme/myenv/commit/232924a0cd51ab4902a3e45a6a3ff25e2d0b5bd8&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>そういえばこれ、iterm2_shell_integration.zsh を読み込んだ後に &lt;code>PROMPT&lt;/code> を設定してるけど、ちゃんと動いてるな。不思議だ。。&lt;/p>
&lt;p>Auto Command Completionも有効にしてみた。&lt;br>
これをONにすると、zsh-autosuggestionの方はカニバって動かないようだったので、Shell Integrationが有効なときはzsh-autosuggestionを使わないようにした:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/progrhyme/myenv/commit/dd1b7d023fdcd9b69343e6e57a2d7280d6071003">https://github.com/progrhyme/myenv/commit/dd1b7d023fdcd9b69343e6e57a2d7280d6071003&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>それにしても、Shell Integrationの機能の多くは既にpecoで実現していたな。。&lt;/p>
&lt;p>（追記）Auto Command Completionはたくさん表示されると迷うし、タブ補完が効かなくなってちょっとお節介な感じなので、やっぱりzsh-autosuggestionに戻した。&lt;/p>
&lt;h4 id="所感">所感&lt;/h4>
&lt;p>慣れたら少しは生産性上がるかも。&lt;/p>
&lt;h3 id="iterm2だとvimのdefault-colorschemeの設定が変わっている">iTerm2だとVimのdefault colorschemeの設定が変わっている&lt;/h3>
&lt;p>なぜかわからないが、ターミナル.appと比べると &lt;code>:highlight&lt;/code> の結果にだいぶ差があった。&lt;/p>
&lt;p>iTerm2が256色対応だから？&lt;/p>
&lt;p>.vimrc で &lt;code>colorscheme elflord&lt;/code> を設定するとややマシになった。&lt;/p>
&lt;p>参考: &lt;a href="https://progrhy.me/tech-notes/a/program/vim/vimrc/#colorscheme">vimrc#colorscheme&lt;/a>&lt;/p></description></item><item><title>A: 2020 archive</title><link>https://progrhy.me/tech-notes/a/memo/2020/</link><pubDate>Wed, 01 Jan 2020 15:38:43 +0900</pubDate><guid>https://progrhy.me/tech-notes/a/memo/2020/</guid><description/></item></channel></rss>